\section{Stato}
\label{sec:chapter_2_section_2}

The application state is modeled using the data structure shown in Listing~\ref{lst:structure}. It is essentially a collection of layers, each containing a collection of vertices, lines, areas and objects, each one of which is captured in a structure composed by: (i) information required by the object prototype; (ii) references mapping the relationship to other objects; (iii) metadata, namely the object customization entry point. Listings~\ref{lst:vertex} and \ref{lst:line} give examples of data structures adopted to model a vertex and a line, respectively.

Information redundancies are exploited to decrease access times. Collections of objects are indexed by \texttt{id} thus allowing lookup in constant time, The \texttt{selected} field of each layer, grants direct access to selected elements without searching.

The state can be loaded one layer at a time to support state fragmentation thus allowing to deal with very big building modeling project.

\subsubsection*{Unidirectional data flow} The described data structure represents the centralized state required by the \emph{unidirectional data flow pattern}~\cite{uniflow} exploited by the application via \emph{Redux.js}\footnote{\url{http://redux.js.org/}} library. The pattern prescribes that the state may be modified only by specific actors, called \emph{reducers}, whose activities are triggered by specific \emph{actions} which contain all the information needed by each reducer to accomplish the state change. Each application feature has to be implemented therefore as a couple of well isolated pieces of code (\emph{action} / \emph{reducer}). Preliminary experiments\footnote{\url{https://github.com/cvdlab/walle}} on 2D drawing tools, in fact, highlighted the development complexity of an application of this kind in terms of large internal state modified by several user interactions, which was to be listened to and applied, resulting in a high coupling level between application logic and user interface. In our setup instead we defined a \emph{state engine}, which represents the application logic, comprising actions and reducers, and encapsulates the centralized state. On this layer can transparently rely different interfaces.
\newpage
\begin{lstlisting}[
  language=javascript,
  basicstyle=\tiny %or \small or \footnotesize etc.
  ]
    "width": 3000, // canvas width
    "height": 2000, // canvas height
    "unit": "cm",  // unit of measurement
    "selectedLayer": "layer-1", // current layer
    "layers": {
      "layer-1": {
        "name": "default",
        "id": "layer-1",
        "altitude": 0,
        "opacity": 1,
        "visible": true,
        "vertices": {
          "HJAe59YF8Ux": {...}
          // ...
        },
        "lines": {
          "Hype99FK88x": {...}
          // ...
        },
        "openings": {
          "r1jaKYUIg": {...}
          // ...
        },
        "areas": {
          "Byg1oFKUIe": {...}
          // ...
        },
        "objects": {
          "rkKU89U8e": {...}
          // ...
        },
       //selected element
        "selected": {
          "vertices": [],
          "lines": [],
          "openings": [],
          "areas": [],
          "objects": ["rkKU89U8e"]
        }
      }
    }
  }
\end{lstlisting}

\subsubsection*{Immutability pattern} \emph{Immutability pattern}~\cite{immutability} is also applied, to avoid side effects on state changes performed by reducers. The state can be seen as an immutable tree structure whose changes are applied as follows: (i) clone the previous state \texttt{s} obtaining a new state \texttt{s'}; (ii) apply changes on the cloned state \texttt{s'}; (iii) Update reference from \texttt{s} to \texttt{s'}. It is worth noting that this approach provides out-of-the-box support for undo/redo operations: an older/newer state can be restored by means of a replacement of the current state with the previous/next one.


Despite its simplicity, this pattern can nevertheless lead to memory waste, due to the several copies of the state that must be held in memory. We addressed this issue using \emph{Immutable.js}\footnote{\url{https://facebook.github.io/immutable-js/}}, a library which exploits structural sharing via hash maps tries and vector tries, thus minimizing the need to copy or cache data.
