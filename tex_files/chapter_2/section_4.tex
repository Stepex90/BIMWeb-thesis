\section{Stato dell'applicazione}
\label{sec:chapter_2_section_4}

Lo stato dell'applicazione è modellato utilizzando la struttura dei dati mostrata nel listato~\ref{lst:struttura}.
Si tratta essenzialmente di un insieme di \emph{layers}, ciascuno contenente un insieme di vertici, linee, aree
ed oggetti, ognuno dei quali è racchiuso in una struttura composta da:
\begin{itemize}
\item le informazioni necessarie dal prototipo dell'oggetto;
\item i riferimenti per la mappatura e la relazione con gli altri oggetti;
\item i metadati, tra cui ad esempio il punto in cui posizionare l'oggetto.
\end{itemize}

La ridondanza delle informazioni viene sfruttata per ridurre i tempi di accesso. Collezioni di oggetti
sono indicizzati da un identificativo univoco \texttt{id} permettendo la ricerca in tempo costante, del
campo \texttt{selected} di ogni layer, consente l'accesso diretto ad elementi selezionati senza cercare.
Lo stato può essere caricato un layer alla volta, consentendo la frammentazione dello stato così,
come può avvenire in un progetto di modellazione di un edificio molto grande.\\
riscrivere tutto

\newpage
% The application state is modeled using the data structure shown in Listing~\ref{lst:structure}.
% It is essentially a collection of layers, each containing a collection of vertices, lines, areas
%  and objects, each one of which is captured in a structure composed by: (i) information required
%   by the object prototype; (ii) references mapping the relationship to other objects; (iii) metadata,
%    namely the object customization entry point. Listings~\ref{lst:vertex} and \ref{lst:line}
%    give examples of data structures adopted to model a vertex and a line, respectively.
% Information redundancies are exploited to decrease access times. Collections of objects
%  are indexed by \texttt{id} thus allowing lookup in constant time, The \texttt{selected}
%   field of each layer, grants direct access to selected elements without searching.
% The state can be loaded one layer at a time to support state fragmentation thus allowing
%  to deal with very big building modeling project.


% The described data structure represents the centralized state required by the \emph{unidirectional data flow pattern}
% ~\cite{uniflow} exploited by the application via \emph{Redux.js}\footnote{\url{http://redux.js.org/}} library.
% The pattern prescribes that the state may be modified only by specific actors, called \emph{reducers},
%  whose activities are triggered by specific \emph{actions} which contain all the information needed by
%   each reducer to accomplish the state change. Each application feature has to be implemented therefore
%    as a couple of well isolated pieces of code (\emph{action} / \emph{reducer}). Preliminary experiments
%    \footnote{\url{https://github.com/cvdlab/walle}} on 2D drawing tools, in fact,
%    highlighted the development complexity of an application of this kind in terms
%    of large internal state modified by several user interactions, which was to be
%    listened to and applied, resulting in a high coupling level between application logic and user interface.
%     In our setup instead we defined a \emph{state engine}, which represents the application logic, comprising
%      actions and reducers, and encapsulates the centralized state. On this layer can transparently rely different interfaces.


% \noindent
% \begin{minipage}{.45\textwidth}
% \begin{lstlisting}[
%                    numbers=left,
%                    frame=trBL,
%                    basicstyle=\tiny,
%                    caption={JSON serialized state, {\tt vertex} structure},
%                    label=struttura]
%   {
%     "id": "HJAe59YF8Ux",
%     "x": 201,
%     "y": 891,
%     "prototype": "vertices",
%     "selected": false,
%     "lines": ["Hype99FK88x", "S1w-hqKKL8e"],
%     "areas": ["Byg1oFKUIe"]
%   }
% \end{lstlisting}
% \end{minipage}\hfill
% \begin{minipage}{.45\textwidth}
% \begin{lstlisting}[
%                    numbers=left,
%                    frame=trBL,
%                    basicstyle=\tiny,
%                    caption={JSON serialized state, {\tt line} structure},
%                    label=struttura]
%   {
%     "id": "Hype99FK88x",
%     "type": "linear",
%     "prototype": "lines",
%     "vertices": ["HJAe59YF8Ux", "r11Z59tKIUg"],
%     "openings": ["r1jaKYUIg", "BJVZ2M9FIIx"],
%     "selected": false,
%     "properties": {
%       "height": 300,
%       "thickness": 20,
%       "coverA": "bricks",
%       "coverB": "bricks"
%    }
% \end{lstlisting}
% \end{minipage}

% \lstset{
%     basicstyle=\fontfamily{cr}\selectfont\footnotesize\color{black},
%     numbers=none, % where to put the line-numbers
%     numberstyle=\tiny, % the size of the fonts that are used for the line-numbers
%     backgroundcolor=\color{white},
%     showspaces=false, % show spaces adding particular underscores
%     showstringspaces=false, % underline spaces within strings
%     showtabs=false, % show tabs within strings adding particular underscores
%     frame=single, % adds a frame around the code
%     tabsize=2, % sets default tabsize to 2 spaces
%     captionpos=b, % sets the caption-position to bottom
%     breaklines=true, % sets automatic line breaking
%     breakatwhitespace=false,
%     xleftmargin=17pt,
%     framexleftmargin=17pt,
%     framexrightmargin=17pt,
%     framexbottommargin=5pt,
%     framextopmargin=5pt
% }


\begin{lstlisting}[
                   numbers=left,
                   frame=trBL,
                   basicstyle=\tiny,
                   caption={stato serializzato in JSON, struttura complessiva},
                   label={lst:struttura}]
{
  "width": 3000, // canvas width
  "height": 2000, // canvas height
  "unit": "cm",  // unit of measurement
  "selectedLayer": "layer-1", // current layer
  "layers": {
    "layer-1": {
      "name": "default",
      "id": "layer-1",
      "altitude": 0,
      "opacity": 1,
      "visible": true,
      "vertices": {
        "HJAe59YF8Ux": {...}
        // ...
      },
      "lines": {
        "Hype99FK88x": {...}
        // ...
      },
      "openings": {
        "r1jaKYUIg": {...}
        // ...
      },
      "areas": {
        "Byg1oFKUIe": {...}
        // ...
      },
      "objects": {
        "rkKU89U8e": {...}
        // ...
      },
     //selected element
      "selected": {
        "vertices": [],
        "lines": [],
        "openings": [],
        "areas": [],
        "objects": ["rkKU89U8e"]
      }
    }
  }
}
\end{lstlisting}
\newpage

\subsubsection*{Flusso dati unidirezionale}
\noindent
La struttura dei dati descritta rappresenta lo stato centralizzato richiesto dal \emph{Unidirectional data flow pattern}
~\cite{uniflow} sfruttato dall'applicazione tramite la libreria \emph{Redux.js}\footnote{\url{http://redux.js.org/}}.
Il modello prevede che lo stato possa essere modificato solo da attori specifici, chiamati \emph{reducers},
le cui attività sono eseguite da specifiche \emph{actions} che contengono tutte le informazioni necessarie per
ogni reducer per realizzare il cambiamento nello stato. Ogni caratteristica applicazione deve essere attuata di conseguenza
come una porzione di codice a sé stanti(\emph{action}/\emph{reducer}).\\ sistemare
Esperimenti preliminari
\footnote{\url{https://github.com/cvdlab/walle}} su strumenti di disegno 2D, infatti,
hanno evidenziato la complessità di sviluppo di un'applicazione di questo tipo in termini di complessità di gestione
dello stato interno dell'applicazione che viene modificato da diverse interazioni con l'utente,
e che comporti un'associazione tra l'evento scatenato dall'utente sull'interfaccia e la logica dell'applicazione.
Nell'archiettetura del framework, si definisce uno \emph{state engine}, che rappresenta la logica dell'applicazione,
che comprende actions e reducers e ne incapsula lo stato centralizzato.
Di questo strato ne fanno uso in modo trasparente le differenti interfacce.

\subsubsection*{Immutability pattern}
L'\emph{Immutability pattern}~\cite{immutability} si applica anche per evitare effetti collaterali sui cambiamenti di stato
eseguiti dai reducers. Lo stato può essere visto come una struttura immutabile ad albero le cui modifiche vengono applicate come segue:
\begin{itemize}
  \item clonazione dello stato precedente \texttt{s} per ottenere un nuovo stato \texttt{s'};
  \item applicazione delle modifiche sullo stato clonato \texttt{s'};
  \item aggiornamento del riferimento da \texttt{s} a \texttt{s'}.
\end{itemize}
Vale la pena notare che questo approccio fornisce il supporto per operazioni out-of-the-box come undo/redo:
un stato vecchio/recente possono essere ripristinati mediante sostituzione dello stato attuale con Il precedente/successivo.
Nonostante la sua semplicità, questo modello può tuttavia comportare sprechi di memoria, a causa delle diverse copie dello
stato che deve che si terrà in memoria. Abbiamo affrontato questo problema utilizzando \emph{Immutable.js}
\footnote{\url{https://facebook.github.io/immutable-js/}}, una libreria che sfrutta la condivisione strutturale tramite
processi con mappe hash e vettoriali, riducendo al minimo la necessità di copiare o mettere i dati in una cache appositamente creata.


% \emph{Immutability pattern}~\cite{immutability} is also applied, to avoid side effects on state changes performed by reducers.
%  The state can be seen as an immutable tree structure whose changes are applied as follows: (i) clone the previous state
%  \texttt{s} obtaining a new state \texttt{s'}; (ii) apply changes on the cloned state \texttt{s'}; (iii) Update reference
%   from \texttt{s} to \texttt{s'}. It is worth noting that this approach provides out-of-the-box support for undo/redo
%   operations: an older/newer state can be restored by means of a replacement of the current state with the previous/next one.
% Despite its simplicity, this pattern can nevertheless lead to memory waste, due to the several copies of the state that must
% be held in memory. We addressed this issue using \emph{Immutable.js}\footnote{\url{https://facebook.github.io/immutable-js/}},
%  a library which exploits structural sharing via hash maps tries and vector tries, thus minimizing the need to copy or cache
%  data.
