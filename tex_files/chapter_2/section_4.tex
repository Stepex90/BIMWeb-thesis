\section{Stato dell'applicazione}
\label{sec:chapter_2_section_4}

Lo stato dell'applicazione è modellato utilizzando la struttura dei dati mostrata nel listato~\ref{lst:struttura}.
Si tratta essenzialmente di un insieme di \emph{layers}, ciascuno contenente un insieme di vertici, linee, aree
ed oggetti, ognuno dei quali è racchiuso in una struttura composta da:
\begin{itemize}
\item le informazioni necessarie dal prototipo dell'oggetto;
\item i riferimenti per la mappatura e la relazione con gli altri oggetti;
\item i metadati, tra cui ad esempio il punto in cui posizionare l'oggetto.
\end{itemize}

La ridondanza delle informazioni viene sfruttata per ridurre i tempi di accesso. Collezioni di oggetti
sono indicizzati da un identificativo univoco \texttt{id} permettendo la ricerca in tempo costante, del
campo \texttt{selected} di ogni layer, questo consente l'accesso diretto ad elementi selezionati senza cercare.
Lo stato dell'applicazione può essere caricato un layer alla volta, consentendo la visualizzazione del solo layer selezionato,
come può avvenire in un framework di modellazione Desktop.\\

\newpage

\lstset{
    basicstyle=\fontfamily{cr}\selectfont\footnotesize\color{black},
    numbers=none, % where to put the line-numbers
    numberstyle=\tiny, % the size of the fonts that are used for the line-numbers
    backgroundcolor=\color{white},
    showspaces=false, % show spaces adding particular underscores
    showstringspaces=false, % underline spaces within strings
    showtabs=false, % show tabs within strings adding particular underscores
    frame=single, % adds a frame around the code
    tabsize=2, % sets default tabsize to 2 spaces
    captionpos=b, % sets the caption-position to bottom
    breaklines=true, % sets automatic line breaking
    breakatwhitespace=false,
    xleftmargin=17pt,
    framexleftmargin=17pt,
    framexrightmargin=17pt,
    framexbottommargin=5pt,
    framextopmargin=5pt
}


\begin{lstlisting}[
                   numbers=left,
                   frame=trBL,
                   basicstyle=\tiny,
                   caption={stato serializzato in JSON, struttura complessiva},
                   label={lst:struttura}]
{
  "width": 3000, // canvas width
  "height": 2000, // canvas height
  "unit": "cm",  // unit of measurement
  "selectedLayer": "layer-1", // current layer
  "layers": {
    "layer-1": {
      "name": "default",
      "id": "layer-1",
      "altitude": 0,
      "opacity": 1,
      "visible": true,
      "vertices": {
        "HJAe59YF8Ux": {...}
        // ...
      },
      "lines": {
        "Hype99FK88x": {...}
        // ...
      },
      "openings": {
        "r1jaKYUIg": {...}
        // ...
      },
      "areas": {
        "Byg1oFKUIe": {...}
        // ...
      },
      "objects": {
        "rkKU89U8e": {...}
        // ...
      },
     //selected element
      "selected": {
        "vertices": [],
        "lines": [],
        "openings": [],
        "areas": [],
        "objects": ["rkKU89U8e"]
      }
    }
  }
}
\end{lstlisting}
\newpage

\subsubsection*{Flusso dati unidirezionale}
\noindent
La struttura dei dati descritta rappresenta lo stato centralizzato richiesto dal \emph{Unidirectional data flow pattern}
~\cite{uniflow} sfruttato dall'applicazione tramite la libreria \emph{Redux.js}\footnote{\url{http://redux.js.org/}}.
Il modello prevede che lo stato possa essere modificato solo da attori specifici, chiamati \emph{reducers},
le cui attività sono eseguite da specifiche \emph{actions} che contengono tutte le informazioni necessarie per
ogni reducer per realizzare il cambiamento nello stato. Ogni caratteristica applicazione deve essere attuata di conseguenza
come una porzione di codice a sé stanti(\emph{action}/\emph{reducer}).
Esperimenti preliminari \footnote{\url{https://github.com/cvdlab/walle}} su strumenti di disegno 2D, infatti,
hanno evidenziato la complessità di sviluppo di un'applicazione di questo tipo in termini di complessità di gestione
dello stato interno dell'applicazione che viene modificato da diverse interazioni con l'utente,
e che comporti un'associazione tra l'evento scatenato dall'utente sull'interfaccia e la logica dell'applicazione.
Nell'archiettetura del framework, si definisce uno \emph{state engine}, che rappresenta la logica dell'applicazione,
che comprende actions e reducers e ne incapsula lo stato in modo centralizzato.
\newpage

\subsubsection*{Immutability pattern}
L'\emph{Immutability pattern}~\cite{immutability} si applica anche per evitare effetti collaterali sui cambiamenti di stato
eseguiti dai reducers. Lo stato può essere visto come una struttura immutabile ad albero le cui modifiche vengono applicate come segue:
\begin{itemize}
  \item clonazione dello stato precedente \texttt{s} per ottenere un nuovo stato \texttt{s'};
  \item applicazione delle modifiche sullo stato clonato \texttt{s'};
  \item aggiornamento del riferimento da \texttt{s} a \texttt{s'}.
\end{itemize}
Vale la pena notare che questo approccio fornisce il supporto per operazioni out-of-the-box come undo/redo:
un stato vecchio/recente possono essere ripristinati mediante sostituzione dello stato attuale con Il precedente/successivo.
Nonostante la sua semplicità, questo modello può tuttavia comportare sprechi di memoria, a causa delle diverse copie dello
stato che deve che si terrà in memoria. Abbiamo affrontato questo problema utilizzando \emph{Immutable.js}
\footnote{\url{https://facebook.github.io/immutable-js/}}, una libreria che sfrutta la condivisione strutturale tramite
processi con mappe hash e vettoriali, riducendo al minimo la necessità di copiare o mettere i dati in una cache appositamente creata.
\newpage
